install.packages("gridExtra")
install.packages("maptools")
install.packages("maptools")
install.packages("gpclib")
install.packages("maptools")
require("XML")
require("plyr")
require("ggplot2")
require("gridExtra")
require("stringr")
library(maptools)
library(PBSmapping)
#install.packages("XML")
#install.packages("maptools")
#install.packages("PBSmapping")
#install.packages("gridExtra")
#install.packages("gpclib")
require("XML")
require("plyr")
require("ggplot2")
require("gridExtra")
require("stringr")
library(maptools)
library(PBSmapping)
setwd("D:/빅데이터MBA/R프로그래밍/R")
load("subwayStn_CP949.RData") #맥등??? 경우??? load("subwayStn_UTF8.RData")
head(subwayStn)
### coordChange ?????? --------
substnGPS <- subwayStn
substnGPS$latitude <- NA
substnGPS$longitude <- NA
head(substnGPS)
transCoord <- function (addrDb, from=1, to=dim(addrDb)[1]) {
for (j in from:to) {
STN_ID <- paste0(addrDb[j,"STN_ID"])
tgtNm <- paste0(addrDb[j,"STN_NM"])
tgtln <- paste0(addrDb[j,"LINE_NM"])
tgtLat <- paste0(addrDb[j,"lat"])
tgtLong <- paste0(addrDb[j,"long"])
#'
#'
#'
url <- "http://apis.daum.net/local/geo/transcoord?apikey="
#url <- "https://apis.daum.net/local/geo/transcoord?apikey="
#'
#' ?????? developer??????????????? 발급받??? API key??? ???????????? ???.
#'
url <- paste(url,"b8337f038a6d27c0de69fadf704e1669","&x=", sep="")
url <- paste(url,tgtLong,"&y=",tgtLat,"&fromCoord=WGS84&toCoord=TM",sep="")
#'
#' iconv????????? ???글 ???코딩??? 바꾸??? 주는 ?????????.
#' ?????? ????????? 검?????? ?????? 것이??? ???글??? UTF-8?????? ???코딩??? ????????? ????????? ???.
#'
url2 <- iconv(url, localeToCharset()[1],"UTF-8")
res <- xmlTreeParse(URLencode(url2), getDTD=F)
output <- xmlRoot(res)
outdf <- data.frame(c())
cat(STN_ID,"_",tgtNm, "\n")
cat(tgtLat, "to TM Coordinate latitude ",xmlAttrs(output)[2],"\n")
cat(tgtLong, "to TM Coordinate longitude",xmlAttrs(output)[1],"\n")
addrDb[j,"longitude"] <- xmlAttrs(output)[1]
addrDb[j,"latitude"] <- xmlAttrs(output)[2]
}
return(addrDb)
}
substnTM <- transCoord(substnGPS)
head(substnTM)
# save(substnTM, file="substnTM.RData")
load("Shape.RData")
head(Shape)
tail(Shape)
# Data EDA
#install.packages("dplyr")
library(dplyr)
Shape %>%
group_by(PID) %>%
summarize(N=n())
Shape %>%
group_by(PID) %>%
summarize(N=n()) %>%
sum(.$N)
start.time <- Sys.time()
plotPolys(Shape)
Sys.time() - start.time
#
# for (i in 1:17) {
#   seoulShape <- Shape[Shape$PID == i,]
#   plotPolys(seoulShape, main=i)
# }
stnPointData <- data.frame(EID=as.numeric(substnTM$STN_ID),X=as.numeric(substnTM$longitude),
Y=as.numeric(substnTM$latitude), stringsAsFactors=F)
str(stnPointData)
stnEventData <- as.EventData(stnPointData, projection=NA)
plotPolys(Shape)
addPoints(stnEventData, col="red", cex=0.5, pch=16)
# 그래???가 ??? ???????????? ????????? ????????? ??????링이 부족하??? ???문임.
seoulShape <- Shape[Shape$PID %in% c(14,9,17),]
plotPolys(seoulShape)
seoulShape <- Shape[Shape$PID %in% c(14,9,17) & Shape$X > 100000,]
plotPolys(seoulShape)
plotPolys(seoulShape)
addPoints(stnEventData, col="blue", cex=0.5, pch=16)
install.packages("XML")
install.packages("maptools")
install.packages("PBSmapping")
install.packages("gridExtra")
install.packages("gpclib")
require("XML")
require("plyr")
require("ggplot2")
require("gridExtra")
require("stringr")
library(maptools)
library(PBSmapping)
load("subwayStn_CP949.RData") #맥등??? 경우??? load("subwayStn_UTF8.RData")
head(subwayStn)
substnGPS <- subwayStn
substnGPS$latitude <- NA
substnGPS$longitude <- NA
head(substnGPS)
transCoord <- function (addrDb, from=1, to=dim(addrDb)[1]) {
for (j in from:to) {
STN_ID <- paste0(addrDb[j,"STN_ID"])
tgtNm <- paste0(addrDb[j,"STN_NM"])
tgtln <- paste0(addrDb[j,"LINE_NM"])
tgtLat <- paste0(addrDb[j,"lat"])
tgtLong <- paste0(addrDb[j,"long"])
#'
#'
#'
url <- "http://apis.daum.net/local/geo/transcoord?apikey="
#url <- "https://apis.daum.net/local/geo/transcoord?apikey="
#'
#' ?????? developer??????????????? 발급받??? API key??? ???????????? ???.
#'
url <- paste(url,"b8337f038a6d27c0de69fadf704e1669","&x=", sep="")
url <- paste(url,tgtLong,"&y=",tgtLat,"&fromCoord=WGS84&toCoord=TM",sep="")
#'
#' iconv????????? ???글 ???코딩??? 바꾸??? 주는 ?????????.
#' ?????? ????????? 검?????? ?????? 것이??? ???글??? UTF-8?????? ???코딩??? ????????? ????????? ???.
#'
url2 <- iconv(url, localeToCharset()[1],"UTF-8")
res <- xmlTreeParse(URLencode(url2), getDTD=F)
output <- xmlRoot(res)
outdf <- data.frame(c())
cat(STN_ID,"_",tgtNm, "\n")
cat(tgtLat, "to TM Coordinate latitude ",xmlAttrs(output)[2],"\n")
cat(tgtLong, "to TM Coordinate longitude",xmlAttrs(output)[1],"\n")
addrDb[j,"longitude"] <- xmlAttrs(output)[1]
addrDb[j,"latitude"] <- xmlAttrs(output)[2]
}
return(addrDb)
}
substnTM <- transCoord(substnGPS)
showMoney <- function(kor, eng, math, pm){
testAvg <- (kor + eng + math)/3
if (testAvg >= 90) {
pocketMoneyToBe <- pm * 1.1
} else {
pocketMoneyToBe <- pm
}
return(pocketMoneyToBe)
}
showMoney(90, 80, 70, 10000)
showMoney(eng=90, 80, 70, 10000)
showMoneyWithPrint <- function(kor, eng, math, pm){
testAvg <- (kor + eng + math)/3
if (testAvg >= 90) {
pocketMoneyToBe <- pm * 1.1
} else {
pocketMoneyToBe <- "please, Try Hard"
}
print(kor)
print(eng)
print(math)
print(pm)
return(pocketMoneyToBe)
}
showMoneyWithPrint(eng = 80, 90, 70, 10000) #automatically arrange arguments and value.
showMoneyWithPrint(90, 80, 70) # one of argument is missing. error.
showMoneyWithWarning <- function(kor, eng, math, pm=10000, warn="please try hard!"){
testAvg <- (kor + eng + math)/3
if (testAvg >=90) {
pocketMoneyToBe <- pm * 1.1
} else {
pocketMoneyToBe <- warn
}
return(pocketMoneyToBe)
}
showMoneyWithWarning(90, 80, 70, "this is your last chance.") # good
showMoneyWithWarning(90, 90, 90, "this is your last chance.") # error
showMoneyWithWarning(90, 90, 90, warn="this is your last chance.") # good
install.packages("pryr")
library(pryr)
x <- 3
address(x)   #?޸𸮻??? ?ּҰ? ??Ÿ????.
address(3) # error  ?????? ?ƴ?. ???????? ??????.
address(pi)
address
mem_view <- function(x) capture.output(.Internal(inspect(x)))
inspect("a")  # STRSXP 0x156f8c18     CHARSXP 0xc159230 ???? ???????? ????.
.Internal(inspect("a"))
head(memoryTour)
myVector <- c(1,2,3,4,5)
mem_view(myVector)
myInteger <- 1:5
mem_view(myInteger)
c(1,2,3,4,5,6,7,8,9,10)
mem_view(1,2,3,4,5,6,7,8,9,10)
x <- c(1,2,3,4,5,6,7,8,9,10)
mem_view(x)
z <- c(1:10)
y <- 1:10
identical(x, y)
identical(x, z)
identical(y, z)
mem_view(x)
mem_view(y)
mem_view(z)
str(x)
str(y)
str(z)
?int
str(1)
str(1.2)
str(1.23)
str(1.23L)
str(1L)
seq(1, 10, 2) # from, to, by
rep(1:3, 3)
rep(1:3, times=3)
rep(1:3, times=3, each=2)
sample(1:10, 10, replace=TRUE)  # ???ø????? ?Լ? ?????? ???? ?ֵ??? ????
sample(1:10, 10, replace=FALSE)  # 위와 동일 하지만 중복 불가
myVector <- sample(1:10, 5, replace=TRUE)
set.seed(1)
myVector <- sample(1:10, 5, replace=TRUE)
set.seed(2)
herVector <- sample(1:10, 5, replace=TRUE)
myVector
herVector
setdiff(myVector, herVector) #  3,4 ?? ?ٸ? ???̴? ???? ?????? ???? ???? ?ٸ??? ????
setdiff(herVector, myVector)
intersect(myVector, herVector)  # ?????? ??�� ȣ??
intersect(myVector, herVector)  # 교집합
union(myVector, herVector)  #합집합
set.seed(123)
myVector <- sample(1:50, 20, replace=TRUE)
set.seed(345)
herVector <- sample(1:50, 10, replace=TRUE)
myVector
herVector
setdiff(myVector, 1:50) # beware the order of argument and compare the results.
setdiff(1:50, myVector)
sampled <- rep(1:5,1)
sampled
eachSampled <- rep(1:5,1,each=2)
eachSampled
identical(sampled, eachSampled) # not identical
setequal(sampled, eachSampled)  # but two sets has equal unique elements.
seqAlongVector <- seq(1,20,2)
length(seqAlongVector)
seq_along(seqAlongVector)  # seq?? index?? ?????ش?.
?seq_along
seqAlongVector
test <- 1:50
seq_along(test)
seq_len(test)
seqAlongVector[seq_along(seqAlongVector)]
seq_along(myVector) # making a sequence from 1 to length of input vector. very convenient!!
myVector
x<-seq(1,10,1)
y<-seq(2,11,1)
x + y
