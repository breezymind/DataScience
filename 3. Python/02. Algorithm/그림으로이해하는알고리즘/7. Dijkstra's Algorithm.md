# 다익트라 알고리즘 ( Dijkstra's Algorithm )

- 그래프의 간선에 가중치를 준 가중 그래프(Weighted Graph)를 학습.
- 가중 그래프에서의 최단 경로를 구하는 알고리즘.
- Cycle이 있는 경우 다익스트라 알고리즘을 쓸 수 없다는 것을 학습.



## 1. 너비 우선 탐색 vs 다익스트라 알고리즘

- 너비우선 탐색의 경우 최단으로 수행하여 진행하는 그래프라고 생각하면 됨.
  - 모든 행동에 대해 더해지는 가중치는 동일하다.
- 다익스트라 알고리즘 : 구간의 시간을 측정하여 많은 횟수를 이동하더라도 짧게 갈 수 있는 거리를 찾는다.
  - 진흙밭길, 고속도로 등 다양한 형태의 경로가 존재할 것이다.



## 2. 다익스트라 알고리즘

```sequence
출발->A: 6분
출발->B: 2분
A->B: 3분
A->도착: 1분
B->도착: 5분
```

- 너비우선 탐색
  - 가장 횟수가 적은 출발 -> A or B -> 도착 2가지 경우
  - 시간 상
    - A 선택 : 7분
    - B 선택 : 7분 
- 다익스트라
  - 시간 고려 : **출발 -> B -> A -> 도착 : 6분**



### 단계

---

1. 가장 가중치가 적은 지점을 는다. 즉, 도달하는 시간이 가장 적게 걸리는 정점을 찾는다.
   1. 출발->A : 6분 
   2. 출발->B : 2분
   3. 도착점까지는 알지 못한다. 

2. 이 정점의 이웃 정점들의 가중치를 조사.
   - B의 모든 이웃 정점에 대해 조사
     - A : 3분, 시작 -> B -> A (2 +3, 총 5분)
     - 도착지점 : 5분 ( 시작 -> B -> 도착, 총 7분)
   - A 지점 까지 도착하는데 가장 빠른 시간을 알 수 있다.
     - 시작 -> A : 6분
     - 시작 -> B -> A : 5분 (빠르다)
   - A로 가는 더 짧은거리를 6->5분으로 수정
   - 도착점까지 가는더 짧은 거리(무한대에서 7분으로 수정)

3. 그래프 상의 모든 정점에 대해 이러한 일을 반복

   - 다시 1단계 : 가장 빨리 도착하는 정점을 찾습니다.

   |  A   |  5분  |
   | :--: | :--: |
   |  B   |  2분  |
   |  도착  |  7분  |

   - 다시 2단계: A의 이웃 정점에서의 거리를 구한다
     - A -> 도착 : 1분
     - 최단 거리가 시작 -> B -> A -> 도착 : 2 + 3 + 1 : **6분**으로 단축

4. 최종 경로를 계산.


### 정리

---

1. 가장 가중치가 적은 정점. 즉, 도달하는 데 시간이 가장 적게 걸리는 정점을 찾습니다.
2. 이 정점의 이웃 정점에 대해 현재의 가중치보다 더 낮은 경로가 존재하는지 확인, 존재한다면 가중치를 수정
3. 그래프 상의 모든 정점에 대해 이러한 일을 반복
4. 최조애 경로를 계산(추후 설명)





## 3. 용어 설명

- 가중치(Weight) : 그래피의 간선에 대해 숫자를 가지는데 이러한 것을 가중치라고 한다.
  - 가중 그래프 (weighted graph) : 가중치를 가지는 그래프
  - 균일 그래프(unweighted graph) : 가중치가 존재하지 않는 그래프
  - 최단 경로
    - 가중 그래프 : 다익스트라
    - 균일 그래프 : 너비 우선 탐색
  - 사이클 : 어떤 정점에서 출발하여 한 바퀴 돌아 다시 같은 정점으로 돌아오는 그래프 
    - 사이클을 만나게 된다면 최단 경로를 찾기 힘들다.
    - 다익스트라 알고리즘은 방향성 비순환 그래프 또는 사이클을 가진 경우에는 가중치가 양수일 때 만 적용 가능하다.



## 4. 구현

```sequence
출발->A: 6분
출발->B: 2분
A->B: 3분
A->도착: 1분
B->도착: 5분
```

이 예제를 코딩하려면 3개의 해시 테이블이 필요 

- 그래프

| 출발점  | A    | 6    |
| ---- | ---- | ---- |
|      | B    | 2    |
| A    | 도착점  | 1    |
|      | 도착점  | 1    |
| B    | A    | 3    |
|      | 도착점  | 5    |
| 도착점  |      | -    |

- 가격

| A    | 6          |
| ---- | ---------- |
| B    | 2          |
| 도착점  | $Infinite$ |

- 부모

| A    | 출발점  |
| ---- | ---- |
| B    | 출발점  |
| 도착점  | -    |

- 코드

```python
graph = {}
# 이웃 저장
graph['you'] = ["alice","bob", "claire"]

# 가중치 
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

print(graph["start"].keys) # ["a","b"] 출력
print(graph["start"]["a"]) # 6
print(graph["start"]["b"]) # 2

# 나머지 정점과 그 이웃들도 추가
graph["a"] = {}
graph["a"]["fin"] = 1
graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {} # 도착점에는 이웃이 없다.

# 정점의 Weight를 저장하는 테이블
infinity = float("inf")

costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

# 부모를 위한 헤시테이블
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None

# 각 정점은 한번만 처리
processed = []
```

- 위에 설명했던 단계의 내용들을 수행 해야한다.